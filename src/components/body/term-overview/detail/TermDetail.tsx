// src/components/body/terms-overview/TermDetail.tsx

import React, { useState, useEffect } from "react";
import {
  Input,
  Button,
  message,
  Form,
  Row,
  Col,
  Checkbox,
  Spin,
  Alert,
  InputNumber,
} from "antd";
import { Term } from "autoskola-web-shared-models";
import { useParams, useNavigate } from "react-router-dom";
import { CheckboxChangeEvent } from "antd/es/checkbox";
import moment from "moment";
import { useTermsService } from "../../../../services/useTermsService";

// Component for adding/editing a Term
export const TermDetail: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const termsService = useTermsService();

  // Determine if the form is in Add Mode or Edit Mode
  const isAddMode = id === "add";

  // State for form data
  const [formData, setFormData] = useState<Term>(
    isAddMode
      ? {
          id: "", // Will be generated by the backend
          label: "",
          registrations: [],
          termConfig: { maxRegistrationsCount: 0 },
          isActive: true,
          created: new Date(),
        }
      : {
          id: "",
          label: "",
          registrations: [],
          termConfig: { maxRegistrationsCount: 0 },
          isActive: true,
          created: new Date(),
        }
  );

  const [initialData, setInitialData] = useState<Term | null>(null);
  const [isChanged, setIsChanged] = useState(false);
  const [isEditable, setIsEditable] = useState(isAddMode);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>("");

  // Fetch existing Term data if in Edit Mode
  useEffect(() => {
    const fetchData = async () => {
      if (!isAddMode && id) {
        setLoading(true);
        try {
          const term = await termsService.getTermById(id);
          setFormData(term);
          setInitialData(term);
        } catch (err: any) {
          setError(err.message || "Failed to load term data.");
        } finally {
          setLoading(false);
        }
      }
    };

    fetchData();
  }, [id, isAddMode, termsService]);

  // Handle form input changes
  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>
  ) => {
    const { name, value } = e.target;
    setFormData((prev) => ({ ...prev, [name]: value }));
    trackChanges({ ...formData, [name]: value });
  };

  // Handle changes for numeric input (maxRegistrationsCount)
  const handleNumberChange = (value: number | null) => {
    setFormData((prev) => ({
      ...prev,
      termConfig: { ...prev.termConfig, maxRegistrationsCount: value || 0 },
    }));
    trackChanges({
      ...formData,
      termConfig: { ...formData.termConfig, maxRegistrationsCount: value || 0 },
    });
  };

  // Handle checkbox change for isActive
  const handleCheckboxChange = (e: CheckboxChangeEvent) => {
    setFormData((prev) => ({ ...prev, isActive: e.target.checked }));
    trackChanges({ ...formData, isActive: e.target.checked });
  };

  // Track if any changes have been made to enable the Save button
  const trackChanges = (updatedData: Term) => {
    if (
      isAddMode &&
      Object.values(updatedData).some((val) => val !== "" && val !== true)
    ) {
      setIsChanged(true);
      return;
    }

    if (!initialData) return;

    const hasChanged =
      updatedData.label !== initialData.label ||
      updatedData.termConfig.maxRegistrationsCount !==
        initialData.termConfig.maxRegistrationsCount ||
      updatedData.isActive !== initialData.isActive;

    setIsChanged(hasChanged);
  };

  // Handle Save action
  const handleSave = async () => {
    if (!isChanged && !isAddMode) {
      message.warning("No changes detected.");
      return;
    }

    setLoading(true);
    try {
      if (isAddMode) {
        // Create a new Term
        const newTerm = await termsService.addTerm({
          label: formData.label,
          termConfig: {
            maxRegistrationsCount: formData.termConfig.maxRegistrationsCount,
          },
          isActive: formData.isActive,
        });
        message.success("New term successfully created.");
        navigate(`/app/terms/term-detail/${newTerm.id}`);
      } else {
        // Update existing Term
        const updatedTerm = await termsService.updateTerm(formData);
        message.success("Term successfully updated.");
        setInitialData(updatedTerm);
        setIsChanged(false);
      }
    } catch (err: any) {
      setError(err.message || "Failed to save term.");
    } finally {
      setLoading(false);
    }
  };

  // Handle Delete action
  const handleDelete = async () => {
    if (!formData.id) return;
    setLoading(true);
    try {
      await termsService.deleteTerm(formData.id);
      message.success("Term successfully deleted.");
      navigate("/app/terms");
    } catch (err: any) {
      setError(err.message || "Failed to delete term.");
    } finally {
      setLoading(false);
    }
  };

  // Handle Back action
  const handleBack = () => {
    navigate("/app/terms");
  };

  // Handle Edit toggle
  const handleEditToggle = (e: CheckboxChangeEvent) => {
    setIsEditable(e.target.checked);
    if (!e.target.checked && initialData) {
      setFormData(initialData);
      setIsChanged(false);
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center h-screen">
        <Spin
          tip={isAddMode ? "Creating term..." : "Loading term..."}
          size="large"
        />
      </div>
    );
  }

  if (error) {
    return (
      <div className="flex justify-center items-center h-screen">
        <Alert
          message="Error"
          description={error}
          type="error"
          showIcon
          className="w-1/2"
        />
      </div>
    );
  }

  return (
    <div className="flex justify-center mt-10 bg-gray-100 min-h-screen p-4">
      <div className="w-full max-w-3xl bg-white p-8 rounded-lg shadow-md">
        <h2 className="text-2xl font-semibold text-center mb-6">
          {isAddMode ? "Add New Term" : "Term Details"}
        </h2>

        {/* Edit Toggle (hidden in Add Mode) */}
        {!isAddMode && (
          <div className="flex justify-end mb-4">
            <Checkbox
              checked={isEditable}
              onChange={handleEditToggle}
              className="text-sm"
            >
              Edit
            </Checkbox>
          </div>
        )}

        <Form layout="vertical">
          {/* Term ID (read-only) */}
          {!isAddMode && (
            <Row gutter={16}>
              <Col span={12}>
                <Form.Item label="ID">
                  <Input
                    value={formData.id}
                    disabled
                    className="bg-gray-100 cursor-not-allowed"
                    placeholder="Term ID"
                  />
                </Form.Item>
              </Col>
            </Row>
          )}

          {/* Term Label */}
          <Row gutter={16}>
            <Col span={12}>
              <Form.Item
                label="Term Label"
                rules={[{ required: true, message: "Term label is required." }]}
              >
                <Input
                  name="label"
                  value={formData.label}
                  onChange={handleChange}
                  disabled={!isEditable && !isAddMode}
                  className={`border ${
                    isEditable || isAddMode
                      ? "border-gray-300"
                      : "border-gray-100 cursor-not-allowed"
                  } rounded-md`}
                  placeholder="Enter term label"
                />
              </Form.Item>
            </Col>
          </Row>

          {/* Term Configuration */}
          <Row gutter={16}>
            <Col span={12}>
              <Form.Item
                label="Max Registrations Count"
                rules={[
                  {
                    required: true,
                    message: "Max registrations count is required.",
                  },
                  { type: "number", min: 1, message: "Must be at least 1." },
                ]}
              >
                <InputNumber
                  min={1}
                  value={formData.termConfig.maxRegistrationsCount}
                  onChange={handleNumberChange}
                  disabled={!isEditable && !isAddMode}
                  className={`border ${
                    isEditable || isAddMode
                      ? "border-gray-300"
                      : "border-gray-100 cursor-not-allowed"
                  } rounded-md w-full`}
                  placeholder="Enter maximum registrations count"
                />
              </Form.Item>
            </Col>

            <Col span={12}>
              <Form.Item label="Is Active">
                <Checkbox
                  checked={formData.isActive}
                  onChange={handleCheckboxChange}
                  disabled={!isEditable && !isAddMode}
                >
                  Active
                </Checkbox>
              </Form.Item>
            </Col>
          </Row>

          {/* Creation Date (read-only in Edit Mode) */}
          {!isAddMode && (
            <Row gutter={16}>
              <Col span={12}>
                <Form.Item label="Created At">
                  <Input
                    value={moment(formData.created).format("YYYY-MM-DD HH:mm")}
                    disabled
                    className="bg-gray-100 cursor-not-allowed"
                  />
                </Form.Item>
              </Col>
            </Row>
          )}

          {/* Additional Information (optional) */}
          {/* You can add more fields here if necessary */}

          {/* Action Buttons */}
          <div className="flex justify-between mt-6">
            <Button
              onClick={handleBack}
              className="bg-gray-300 hover:bg-gray-400 text-white"
            >
              Back
            </Button>
            {(isEditable || isAddMode) && (
              <div className="flex space-x-4">
                <Button
                  type="primary"
                  onClick={handleSave}
                  disabled={!isChanged && !isAddMode}
                  className={`${
                    isChanged || isAddMode
                      ? "bg-blue-500 hover:bg-blue-600"
                      : "bg-blue-300 cursor-not-allowed"
                  } text-white`}
                >
                  Save
                </Button>
                {!isAddMode && (
                  <Button
                    danger
                    onClick={handleDelete}
                    className="bg-red-500 hover:bg-red-600 text-white"
                  >
                    Delete
                  </Button>
                )}
              </div>
            )}
          </div>
        </Form>
      </div>
    </div>
  );
};
